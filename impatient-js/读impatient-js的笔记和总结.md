---
title: 读impatient-js的笔记和总结
date: 2020-07-15 10:45:24
tags: js
---
### 第六章 语法(syntax)

#### 6.1 概述

##### 1.注释(comments)

(i)  // 单个注释

(ii) /*

​     多行

​     注释

​     */

##### 2.布尔值(Booleans)

创建 Boolean 对象的语法：

```javascript
new Boolean(value);    //构造函数
Boolean(value);        //转换函数
```

当作为一个构造函数（带有运算符 new）调用时，Boolean() 将把它的参数转换成一个布尔值，并且返回一个包含该值的 Boolean 对象。

如果作为一个函数（不带有运算符 new）调用时，Boolean() 只将把它的参数转换成一个原始的布尔值，并且返回这个值。

**注释：**如果省略 value 参数，或者设置为 0、-0、null、""、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 "false"）。

##### 3.命名约定

串联单词的常见大小写样式为：骆驼、下划线（也称为蛇）、破折号（也称为烤肉串）

通常，JavaScript使用驼峰式大小写，常量除外。

小写：

- 函数，变量： `myFunction`
- 方法： `obj.myMethod`
- CSS：
  - CSS实体： `special-class`
  - 对应的JavaScript变量： `specialClass`

大写：

- 类： `MyClass`

- 常数： 

  ```
  MY_CONSTANT
  ```

  - 常量通常也以驼峰形式编写： `myConstant`

更多：

如果参数名称以下划线开头（或为下划线），则表示未使用此参数-例如：

```
arr.map((_x, i) => i)
```

如果对象的属性名称以下划线开头，则该属性被视为私有：

```javascript
class ValueWrapper {
  constructor(value) {
    this._value = value;
  }
}
```

#### 6.2 标识符(identifiers)

##### 1.有效标识符(变量名等)

变量名称和属性名称的语法类别称为**标识符**。

第一个字符：

- Unicode字母（包括带重音符号的`é`和`ü`和非拉丁字母的字符，例如`α`）
- `$`
- `_`

后续字符：

- 合法的第一个字符
- Unicode数字（包括东方阿拉伯数字）
- 其他一些Unicode标记和标点符号

##### 2.保留字(reserved words)

保留字不能是变量名，但可以是属性名。

不应该使用全局变量的名字(`String`，`Math`)为自己的变量和参数等。

#### 6.3 语句(statement)与表达式(expression)

##### 1.语句

一个语句是一段可被执行的代码，并执行某种动作。例如if语句或函数声明等。

```javascript
function twice(x) {
  return x + x;
}
```

##### 2.表达式

一个表达式是一段可被评估的代码，以产生一个值。

例如，括号之间的代码是一个表达式：

```
let myStr = (myBool ? 'Yes' : 'No');
```

`_?_:_`括号之间使用的运算符称为三元运算符。它是`if`语句的表达式版本。

##### 3.更多规范

- 函数的主体必须是一系列语句
- 函数调用或方法调用的参数必须为表达式
- 表达式可以用作语句，它们被称为表达式语句；反之则不成立

#### 6.4 不明确的语法

##### 1.函数声明和函数表达式

一个函数声明为一个语句：

```javascript
function id(x) {
  return x;
}
```

一个函数表达式是一个表达式（=的右侧）：

```
const id = function me(x) {
  return x;
};
```

##### 2.对象字面量和块

在下面的代码中，`{}`是一个对象字面量：一个创建空对象的表达式。

```
const obj = {};
```

这是一个空的代码块（一条语句）：

```
{
}
```

##### 3.消除分歧

为了解决歧义，以`function`或`{`开头的语句永远不会被解释为表达式。如果要让表达式语句以以下任一标记开头，则必须将其用括号括起来：

```javascript
(function (x) { console.log(x) })('abc');
```

先通过函数表达式创建了一个函数，然后调用它

#### 6.5 分号(semicolons)

##### 1.法则

以大括号结尾的语句后面没有分号；如果有，则被解释为空语句。

##### 2.控制语句(control statements)

如while loop:

```javascript
while (condition)
  statement
```

控制语句的主体就是一个语句，它可以是单个的一条语句，但块也是语句，也可以作为控制语句的主体。

如果下次要一个空的主体，既可以是一个空的语句（只加一个分号），也可以是一个空的块。

#### 6.6 自动分号插入(ASI)

##### 1.工作原理

ASI的工作原理如下。语句的解析将继续进行，直到出现以下任何一种情况：

- 分号
- 行终止符后跟非法令牌

换句话说，ASI可以看作是在换行符处插入分号。

##### 2.意外触发

JavaScript禁止在某些令牌后换行。如果确实插入换行符，也会插入分号。

与实际最相关的令牌是`return`。例如，考虑以下代码：

```javascript
return
{
  first: 'jane'
};
```

这段代码被解析为：

```javascript
return;
{
  first: 'jane';
}
;
```

可以防止意外地返回一行中令牌`return`后的值。

##### 3.最佳做法

建议始终编写分号。

#### 6.7 严格模式(strict)与马虎(sloppy)模式

脚本中的默认模式为普通的“马虎”模式（代码片段是模块的先驱，并受浏览器支持），而严格模式是模块和类中的默认模式，可以在脚本中打开。在此模式下，正常模式的一些陷阱被消除，并且引发了更多异常。

在现代JavaScript代码中，几乎不会遇到马虎模式，该模式几乎总是位于模块中。

##### 1.严格模式

在脚本文件和CommonJS模块中，通过在第一行中放置以下代码，可以为完整文件打开严格模式(ECMAScript 5之前的版本会完全忽略它)：

```javascript
'use strict';
```

还可以仅使用一个功能就打开严格模式：

```javascript
function functionInStrictMode() {
  'use strict';
}
```

##### 2.马虎模式的陷阱

(i)改变未声明的变量将创造全局变量

(ii)函数声明在严格模式中是块作用域但在马虎模式中是函数作用域

在严格模式下，通过函数声明创建的变量仅存在于最里面的封闭块中

(iii)更改不可变数据时，草率模式不会引发异常

在严格模式下，如果尝试更改不可变数据，则会出现异常;而在草率模式下，分配静默失败

### 第十章 变量和赋值(variables and assignments)

#### 10.1 let

通过`let`声明的变量是可变的，而且可以同时声明和赋值

#### 10.2 const

通过`const`声明的变量是不变的，必须立即初始化

##### 1.const和不变

`const`仅表示绑定(变量名称和变量值之间的关联)是不可变的，该值本身可以是可变的，如改变其属性

##### 2.const和循环

使用const和for-of循环，每个迭代都会创建新的绑定，如：

```javascript
const arr = ['hello', 'world'];
for (const elem of arr) {
  console.log(elem);
}
// Output:
// 'hello'
// 'world'
```

但在普通的for循环中，必须使用`let`:

```javascript
...
for (let i=0; i<arr.length; i++) {
  const elem = arr[i];
  ...
}
```

##### 3. 选择

仅在不能使用`const`时用`let`

#### 10.3 一个变量的作用域

##### 1.法则

变量的范围是程序可以访问的区域

通过`const`和`let`声明的变量被称为是块作用域的，因为它们的范围始终是周围的最内部块。

##### 2.阴影变量(Shadowing variables)

不能在同一级别两次声明同一变量，但可以嵌套一个块，在块外声明相同的变量名；在块内部，内部`x`是唯一具有该名称的可访问变量，离开块后，可以再次访问旧值。

#### 10.4 术语(terminology)：静态(static) vs 动态(dynamic)

- *静态*意味着某些东西与源代码有关，无需执行代码即可确定。

- *动态*意味着在运行时。

  ##### 1.静态现象：变量的作用域

  如下：

  ```javascript
  function f() {
    const x = 3;
    // ···
  }
  ```

  x是静态范围，其范围是固定的，并且在运行时不会更改。

  变量的范围形成了一棵静态数。（通过静态嵌套）

  ##### 2.动态现象：函数调用

  函数是否被调用只能在运行时确定。

  函数调用形成一棵动态树（通过动态调用）。

  #### 10.5 全局变量和全局对象

  ##### 1.法则

  JavaScript的变量范围是嵌套的。它们形成一棵树：

  - 最外部的作用域是树的根。

  - 直接包含在该范围中的范围是根的子级。

  根也称为全局范围。在web浏览器中，一个直接位于该范围内的唯一位置是脚本的顶层。全局范围的变量称为全局变量，可在任何地方访问。

  ##### 2.种类

  全局变量有两种：

  - 全局**声明**变量是普通变量。
    - 只能在脚本的顶层通过`const`，`let`和`class`声明来创建它们。
  - **全局对象变量存储在所谓的全局对象的属性中**
    - 它们通过`var`和函数声明在脚本的顶层创建。
    - 可以通过全局变量`globalThis`访问全局对象。它可用于创建，读取和删除全局对象变量。
    - 除此之外，全局对象变量的工作方式与普通变量类似。

  每个ECMAScript模块都有自己的范围，该范围包含在全局范围内。因此，存在于模块顶层的变量不是全局变量。

  #### 10.6 声明：范围(scope)和激活(activation)

  ##### 1.声明的种类

  - 范围：指已声明的实体可以被看到的范围，是一个静态特征。
  - 激活：指可以访问实体的时间，是一个动态特征。有些实体当我们进入它的范围时就可以直接被访问，而其它的必须等到执行到达它们的声明。

  |            | Scope     | Activation       | Duplicates(同一作用域内重复) | Global prop. |
  | ---------- | --------- | ---------------- | ---------------------------- | ------------ |
  | `const`    | Block     | decl. (TDZ)      | `✘`                          | `✘`          |
  | `let`      | Block     | decl. (TDZ)      | `✘`                          | `✘`          |
  | `function` | Block (*) | start            | `✔`                          | `✔`          |
  | `class`    | Block     | decl. (TDZ)      | `✘`                          | `✘`          |
  | `import`   | Module    | same as export   | `✘`                          | `✘`          |
  | `var`      | Function  | start, partially | `✔`                          | `✔`          |

  ##### 2.const and let: temporal dead zone 

  进入变量范围和执行变量声明之间的*时间*称为该变量的时间死区（TDZ）：

  - 在这段时间内，该变量被认为是未初始化的（好像它是一个特殊值）。
  - 如果访问未初始化的变量，则会得到一个`ReferenceError`。
  - 到达变量声明后，将变量设置为初始值设定项的值（通过分配符号指定）或`undefined`–如果没有初始值设定项。
  
  即使函数的声明位于变量的声明之前并使用该变量，我们也可以调用此函数。但是，我们必须等到变量的时间盲区结束。
  
  ##### 3.函数的声明和提前激活
  
  进入函数范围时，无论函数声明在该范围内的什么位置，总是先执行函数声明。这使我们可以在声明函数之前调用它，即提前激活函数。
  
  如果通过`const`或`let`声明函数(表达式)，则不会提早激活它。
  
  
  
  #### 10.7 闭包

### 第十二章 运算符(operators)

#### 12.6 Javascript逻辑运算符“或”的应用

或运算符可以被用来为一个新定义好的变量提供一个默认值:

```javascript
var bar = false,
foobar = 5,
foo = bar || foobar; // foo = 5
```

在上面这个例子当中，只有当bar蕴涵假的时候，foobar才会将它自身的值传递给foo。

如果一个变量有可能是空，那么或运算符可以在函数中用来提供一个默认值：

```javascript
function foo( a, b ){
    a = a || 5;
    b = b || 6;
    console.log( 'Values:' + a + ',' +b );
}
```

